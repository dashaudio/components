<link rel="import" href="../bower/polymer/polymer.html">
<link rel="import" href="../bower/google-chart/google-chart.html">

<dom-module id="dash-chart-time-series">
  <template>
    <style>
      #container {
        width: 100%; height: 100%;
        overflow: hidden;
        display: flex;
        align-content: center;
        align-items: center;
        justify-content: center;
      }

      #empty {
        font-family: "proxima-nova", sans-serif;
        font-size: 11px;
        text-align: center;
      }

      #chart {
        width: 100%; height: 100%;
        transition: opacity 0.5s;
        opacity: 0;
      }

      :host { display: block; }
      ::content rect[height="1"] { fill: #F0F0F0; }
      ::content rect { stroke: none !important; rx: 2px; }
    </style>

    <div id="container">
      <div id="empty" hidden$="{{!empty}}">No Data</div>
      <google-chart id="chart" hidden$="{{empty}}" options="{{googleChartOptions}}" data="{{googleChartData}}" type="column"></google-chart>
    </div>
  </template>

  <script>
    Polymer({
      is: 'dash-chart-time-series',

      properties: {
        data: { type: Array, observer: "dataChanged" },
        empty: Boolean,
        googleChartOptions: Object,
        googleChartData: Array,
        resizeTimerHandle: Number
      },

      listeners: {
        "chart.google-chart-render": "render",
      },

      ready: function() {
        window.addEventListener("resize", this.windowWasResized.bind(this));
      },

      render: function(event) {
        this.$.chart.style.opacity = 1;
      },

      dataChanged: function(data) {
        this.set("empty", (!data || !data.series || !data.series.length));
        if (data) this.refresh(data);
      },

      refresh: function(data) {
        this.set("googleChartOptions", this.googleChartOptionsForData(data));
        this.set("googleChartData", this.googleChartDataForData(data));
      },

      windowWasResized: function() {
        this.$.chart.style.opacity = 0;
        window.clearTimeout(this.resizeTimerHandle);
        this.resizeTimerHandle = window.setTimeout(this.resizeChart.bind(this), 300);
      },

      resizeChart: function() {
        if (this.data) this.$.chart.drawChart();
      },

      googleChartOptionsForData: function(data) {
        if (!data || !data.series || !data.series.length) return null;

        var start = this.startDateForData(data);
        var end = this.endDateForData(data);
        var period = this.periodBetweenDates(start, end);

        return {
          width: "100%",
          height: "100%",
          chartArea: { top: "10%", left: "10%", right: "10%", bottom: "10%", width: "80%", height: "80%" },
          colors: ["#00BFFF", "96E129", "#FB7D34", "#00ACF3", "#FA1C68"],
          fontSize: 11,
          fontName: "proxima-nova, sans-serif",
          vAxis: {
            gridlines: { color: "#F0F0F0" },
            textStyle: { color: "#AAA" },
            format: "short"
          },
          legend: { position: "none" },
          isStacked: true,
          hAxis: {
            format: this.dateFormatStringForPeriod(period),
            viewWindow: this.viewWindowForDates(start, end, period),
            gridlines: {
              count: this.gridlineCountForPeriod(period),
              color: "#F0F0F0"
            },
            textStyle: { color: "#AAA" }
          }
        };
      },

      googleChartDataForData: function(data) {
        if (!data || !data.series || !data.series.length) return null;
        return this.googleChartColsForData(data).concat(this.googleChartRowsForData(data));
      },

      googleChartColsForData: function(data) {
        var cols = [{"label":"Date", "type":"date"}];

        for (var series of data.series) {
          cols.push({ "label": series.id || "Series", type: "number" });
        }

        return [cols];
      },

      googleChartRowsForData: function(data) {
        var allKeys = data.series.reduce(function(previous, current) {
          return previous.concat(current.values.map(function(value) { return value.time; }));
        }, []);

        var uniqueKeys = Array.from(new Set(allKeys));

        var rows = Array(uniqueKeys.length);

        for (var index = 0; index < uniqueKeys.length; index++) {
          rows[index] = [this.dateForDateKey(uniqueKeys[index])];

          for (var seriesIndex = 0; seriesIndex < data.series.length; seriesIndex++) {
            var value = data.series[seriesIndex].values[index];
            rows[index][seriesIndex+1] = value ? value.value : null;
          }
        }

        return rows;
      },

      dateForDateKey: function(key) {
        return moment(key, "x").hours(0).minutes(0).toDate();
      },

      startDateForData: function(data) {
        return moment(data.series[0].values[0].time, "x");
      },

      endDateForData: function(data) {
        return moment(data.series[0].values[data.series[0].values.length-1].time, "x");
      },

      periodBetweenDates: function(start, end) {
        return moment.duration(end.diff(start)).asDays();
      },

      viewWindowForDates: function(start, end, period) {
        return {
          min: start.startOf("day").subtract(12, "hours").toDate(),
          max: end.endOf("day").subtract(12, "hours").toDate()
        }
      },

      dateFormatStringForPeriod(period) {
        if (period < 1) {
          return "EEEE";
        } else if (period < 7) {
          return "EE";
        } else if (period < 31) {
          return "MMMM";
        } else {
          return "yyyy";
        }
      },

      gridlineCountForPeriod: function(period) {
        if (period < 1) {
          return 1;
        } else if (period < 7) {
          return 7;
        } else if (period < 31) {
          return 1;
        } else {
          return 1;
        }
      }
    });
  </script>
</dom-module>
