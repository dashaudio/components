<link rel="import" href="../bower/polymer/polymer.html">
<link rel="import" href="../bower/google-chart/google-chart.html">

<!-- This code is fairly junky. Intended to get us started and be rewritten. -->

<dom-module id="dash-chart-time-series">
  <template>
    <style>
      .container {
        width: 100%; height: 100%;
        overflow: hidden;
      }
      google-chart {
        width: 100%; height: 100%;
        transition: opacity 0.5s;
        opacity: 0;
      }
      ::content rect[height="1"] {
        fill: #F0F0F0;
      }
      ::content rect {
        stroke: none !important;
        rx: 2px;
      }
    </style>

    <div class="container">
      <google-chart id="chart" options="{{googleChartOptions}}" data="{{googleChartData}}" type="column"></google-chart>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'dash-chart-time-series',

    properties: {
      type: String,
      data: { type: Array, observer: "dataChanged" },
      googleChartOptions: Object,
      googleChartData: Array,
      resizeTimerHandle: Number
    },

    listeners: {
      "chart.google-chart-render": "render",
    },

    ready: function() {
      window.addEventListener("resize", this.windowWasResized.bind(this));
    },

    render: function(event) {
      this.$.chart.style.opacity = 1;
    },

    dataChanged: function(data) {
      if (data) this.refresh(data);
    },

    refresh: function(data) {
      this.set("googleChartOptions", this.googleChartOptionsForData(data));
      this.set("googleChartData", this.googleChartDataForData(data));
    },

    windowWasResized: function() {
      this.$.chart.style.opacity = 0.05;
      window.clearTimeout(this.resizeTimerHandle);
      this.resizeTimerHandle = window.setTimeout(this.resizeChart.bind(this), 300);
    },

    resizeChart: function() {
      this.$.chart.drawChart();
    },

    googleChartOptionsForData: function(data) {
      if (!data) return null;
      if (!data.series || !data.series.length) return null;

      var start = this.startDateForData(data);
      var end = this.endDateForData(data);
      var period = this.periodBetweenDates(start, end);

      if (period === 0) {
        data.series[0].values[0].time = moment(data.series[0].values[0].time, "x").hours(0).toDate().getTime();
      }

      return {
        width: "100%",
        height: "100%",
        colors: ["#00BFFF", "96E129", "#FB7D34", "#00ACF3", "#FA1C68"],
        fontSize: 10,
        vAxis: { gridlines: { color: "#F0F0F0" } },
        legend: { position: "none" },
        isStacked: true,
        hAxis: {
          format: this.dateFormatStringForPeriod(period),
          viewWindow: this.viewWindowForDates(start, end),
          gridlines: {
            count: this.gridlineCountForPeriod(period),
            color: "#F0F0F0"
          }
        }
      };
    },

    googleChartDataForData: function(data) {
      if (!data) return null;
      if (!data.series || !data.series.length) return null;

      return this.googleChartColsForData(data).concat(this.googleChartRowsForData(data));
    },

    googleChartColsForData: function(data) {
      var cols = [{"label":"Date", "type":"date"}];

      for (var series of data.series) {
        cols.push({ "label": series.id || "Series", type: "number" });
      }

      return [cols];
    },

    googleChartRowsForData: function(data) {
      var allKeys = data.series.reduce(function(previous, current) {
        return previous.concat(current.values.map(function(value) { return value.time; }));
      }, []);

      var uniqueKeys = Array.from(new Set(allKeys));

      var rows = Array(uniqueKeys.length);

      for (var index = 0; index < uniqueKeys.length; index++) {
        rows[index] = [this.dateForDateKey(uniqueKeys[index])];

        for (var seriesIndex = 0; seriesIndex < data.series.length; seriesIndex++) {
          var value = data.series[seriesIndex].values[index];
          rows[index][seriesIndex+1] = value ? value.value : null;
        }
      }

      return rows;
    },

    dateForDateKey: function(key) {
      return moment(key, "x").hours(0).minutes(0).toDate();
    },

    startDateForData: function(data) {
      return moment(data.series[0].values[0].time, "x");
    },

    endDateForData: function(data) {
      return moment(data.series[0].values[data.series[0].values.length-1].time, "x");
    },

    periodBetweenDates: function(start, end) {
      return moment.duration(end.diff(start)).asDays();
    },

    viewWindowForDates: function(start, end) {
      return {
        min: start.subtract(12, "hours").toDate(),
        max: end.add(12, "hours").toDate()
      };
    },

    dateFormatStringForPeriod(period) {
      if (period < 1) {
        return "'Today'";
      } else if (period < 7) {
        return "EE";
      } else if (period < 31) {
        return "MMMM";
      } else {
        return "yyyy";
      }
    },

    gridlineCountForPeriod: function(period) {
      if (period < 1) {
        return 1;
      } else if (period < 7) {
        return 7;
      } else if (period < 31) {
        return 1;
      } else {
        return 1;
      }
    }
  });
</script>
