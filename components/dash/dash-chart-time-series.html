<link rel="import" href="../bower/polymer/polymer.html">
<link rel="import" href="../bower/google-chart/google-chart.html">

<dom-module id="dash-chart-time-series">
  <template>
    <style>
      .container {
        width: 100%; height: 100%;
        overflow: hidden;
      }
      google-chart {
        width: 100%; height: 100%;
      }
      ::content rect[height="1"] {
        fill: #F0F0F0;
      }
      ::content rect {
        stroke: none !important;
        rx: 2px;
      }
    </style>
    <div class="container">
      <google-chart options="{{googleChartOptions}}" data="{{googleChartData}}" type="column"></google-chart>
    </div>
  </template>
</dom-module>

<script>

  Polymer({

    is: 'dash-chart-time-series',

    properties: {
      data: { type: Array, observer: "dataChanged" },
      googleChartOptions: Object,
      googleChartData: Array
    },

    ready: function() {
      // ...
    },

    dataChanged: function(data) {
      if (data) this.refresh(data);
    },

    refresh: function(data) {
      this.set("googleChartOptions", this.googleChartOptionsForData(data));
      window.setTimeout(function() {
        this.set("googleChartData", this.googleChartDataForData(data));
      }.bind(this), 10);

    },

    googleChartOptionsForData: function(data) {
      if (!data) return null;

      var start = this.startDateForData(data);
      var end = this.endDateForData(data);
      var period = this.periodBetweenDates(start, end);

      if (period === 0) {
        data.series[0].values[0].time = moment(data.series[0].values[0].time, "x").hours(0).toDate().getTime();
      }

      return {
        width: "100%",
        height: "100%",
        colors: ["#00BFFF", "96E129", "#FB7D34", "#00ACF3", "#FA1C68"],
        fontSize: 10,
        vAxis: { gridlines: { color: "#F0F0F0" } },
        legend: { position: "none" },
        isStacked: true,
        hAxis: {
          format: this.dateFormatStringForPeriod(period),
          viewWindow: this.viewWindowForDates(start, end),
          viewWindowMode: "maximized",
          gridlines: {
            count: this.gridlineCountForPeriod(period),
            color: "#F0F0F0"
          }
        }
      };
    },

    googleChartDataForData: function(data) {
      return this.googleChartColsForData(data).concat(this.googleChartRowsForData(data));
    },

    googleChartColsForData: function(data) {
      var cols = [{"label":"Date", "type":"date"}];

      for (var series of data.series) {
        cols.push({"label":series.id || "Series", type: "number"});
      }

      return [cols];
    },

    googleChartRowsForData: function(data) {

      var allKeys = data.series.reduce(function(prev, curr, array) {
        return prev.concat(curr.values.map(function(value) { return value.time; }));
      }, []);

      var uniqueKeys = Array.from(new Set(allKeys));

      var rows = Array(uniqueKeys.length);

      for (var index = 0; index < uniqueKeys.length; index++) {
        rows[index] = [this.dateForDateKey(uniqueKeys[index])];

        for (var seriesIndex = 0; seriesIndex < data.series.length; seriesIndex++) {
          var value = data.series[seriesIndex].values[index];
          rows[index][seriesIndex+1] = value ? value.value : null;
        }
      }

      return rows;

    },

    dateForDateKey: function(key) {
      return moment(key, "x").hours(0).minutes(0).toDate();
    },

    startDateForData: function(data) {
      return moment(data.series[0].values[0].time, "x");
    },

    endDateForData: function(data) {
      return moment(data.series[0].values[data.series[0].values.length-1].time, "x");
    },

    periodBetweenDates: function(start, end) {
      return moment.duration(end.diff(start)).asDays();
    },

    viewWindowForDates: function(start, end) {
      return {
        min: start.subtract(12, "hours").toDate(),
        max: end.add(12, "hours").toDate()
      };
    },

    dateFormatStringForPeriod(period) {
      if (period < 1) {
        return "'Today'";
      } else if (period < 7) {
        return "EE";
      } else if (period < 31) {
        return "MMMM";
      } else {
        return "yyyy";
      }
    },

    gridlineCountForPeriod: function(period) {
      if (period < 1) {
        return 1;
      } else if (period < 7) {
        return 7;
      } else if (period < 31) {
        return 1;
      } else {
        return 1;
      }
    }

  });

</script>
